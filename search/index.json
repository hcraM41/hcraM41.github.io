[{"content":"一、defer的简单使用 defer 拥有注册延迟调用的机制，defer 关键字后面跟随的语句或者函数，会在当前的函数return 正常结束 或者 panic 异常结束 后执行。\n但是defer 只有在注册后，最后才能生效调用执行，return 之后的defer 语句是不会执行的，因为并没有注册成功。\n如下例子：\nfunc main() { defer func() { fmt.Println(111) }() fmt.Println(222) return defer func() { fmt.Println(333) }() } 执行结果：\n222 111 解析：222 、111 是在return 之前注册的，所以如期执行，333 是在return 之后注册的，注册失败，执行不了。\ndefer 在需要资源释放的场景非常有用，可以很方便地在函数结束前执行一些操作。\n比如在 打开连接/关闭连接 、加锁/释放锁、打开文件/关闭文件 这些场景下：\nfile, err := os.Open(\u0026#34;1.txt\u0026#34;) if err != nil { panic(err) } if file != nil { defer file.Close() } 这里要注意的是：在调用file.Close() 之前，需要判断file 是否为空，避免出现异常情况。\n再来看一个错误示范，没有正确使用defer 的例子：\nplayer.mu.Lock() rand.Intn(number) player.mu.Unlock() 这三行代码，存在两个问题： 1. 中间这行代码 rand.Intn(number) 是有可能发生panic 的，这就会导致没有正常解锁。 2. 这样的代码在项目中后续可能被其他人修改，在rand.Intn(number) 后增加更多的逻辑，这是完全不可控的。\n在Lock 和 Unlock 之间的代码一旦出现 panic ，就会造成死锁。因此，即使逻辑非常简单，使用defer 也是很有必要的，因为需求总在变化，代码也总会被修改。\n二、defer的函数参数与闭包引用 defer 延迟语句不会马上执行，而是会进入一个栈，函数return 前，会按先进后出的顺序执行。\n先进后出的原因是后面定义的函数可能会依赖前面的资源，自然要先执行；否则，如果前面的先执行了，那么后面函数的依赖就没有了，就可能会导致出错。\n在defer 函数定义时，对外部变量的引用有三种方式：值传参、指针传参、闭包引用。\n值传参：在defer 定义时就把值传递给defer ，并复制一份cache起来，defer调用时和定义的时候值是一致的。 指针传参：在defer 定义时就把指针传递给defer ，defer调用时根据整个上下文确定参数当前的值。 闭包引用：在defer 定义时就把值引用传递给defer ，defer调用时根据整个上下文确定参数当前的值。 下面通过例子加深一下理解。\n例子1：\nfunc main() { var arr [4]struct{} for i := range arr { defer func() { fmt.Println(i) }() } } 执行结果：\n3 3 3 3 解析：因为defer 后面跟着的是一个闭包，根据整个上下文确定，for 循环结束后i 的值为3，因此最后打印了4个3。\n例子2：\nfunc main() { var n int // 值传参 defer func(n1 int) { fmt.Println(n1) }(n) // 指针传参 defer func(n2 *int) { fmt.Println(*n2) }(\u0026amp;n) // 闭包 defer func() { fmt.Println(n) }() n = 4 } 执行结果：\n4 4 0 解析：\ndefer 执行顺序和定义的顺序是相反的；\n第三个defer 语句是闭包，引用的外部变量n ，defer调用时根据上下文确定，最终结果是4；\n第二个defer 语句是指针传参，defer调用时根据整个上下文确定参数当前的值，最终结果是4；\n第一个defer 语句是值传参，defer调用时和定义的时候值是一致的，最终结果是0；\n例子3：\nfunc main() { // 文件1 f, _ := os.Open(\u0026#34;1.txt\u0026#34;) if f != nil { defer func(f io.Closer) { if err := f.Close(); err != nil { fmt.Printf(\u0026#34;defer close file err 1 %v\\n\u0026#34;, err) } }(f) } // 文件2 f, _ = os.Open(\u0026#34;2.txt\u0026#34;) if f != nil { defer func(f io.Closer) { if err := f.Close(); err != nil { fmt.Printf(\u0026#34;defer close file err 2 %v\\n\u0026#34;, err) } }(f) } fmt.Println(\u0026#34;success\u0026#34;) } 执行结果：\nsuccess 解析：先说结论，这个例子的代码没有问题，两个文件都会被成功关闭。这个是对defer 原理的应用，因为defer 函数在定义的时候，参数就已经复制进去了，这里是值传参，真正执行close() 函数的时候就刚好关闭的是正确的文件。如果不把f 当做值传参，最后两个close() 函数关闭的就是同一个文件了，都是最后打开的那个文件。\n例子3的错误示范：\nfunc main() { // 文件1 f, _ := os.Open(\u0026#34;1.txt\u0026#34;) if f != nil { defer func() { if err := f.Close(); err != nil { fmt.Printf(\u0026#34;defer close file err 1 %v\\n\u0026#34;, err) } }() } // 文件2 f, _ = os.Open(\u0026#34;2.txt\u0026#34;) if f != nil { defer func() { if err := f.Close(); err != nil { fmt.Printf(\u0026#34;defer close file err 2 %v\\n\u0026#34;, err) } }() } fmt.Println(\u0026#34;success\u0026#34;) } 执行结果：\nsuccess defer close file err 1 close 2.txt: file already closed 例子4：\n// 值传参 func func1() { var err error defer fmt.Println(err) err = errors.New(\u0026#34;func1 error\u0026#34;) return } // 闭包 func func2() { var err error defer func() { fmt.Println(err) }() err = errors.New(\u0026#34;func2 error\u0026#34;) return } // 值传参 func func3() { var err error defer func(err error) { fmt.Println(err) }(err) err = errors.New(\u0026#34;func3 error\u0026#34;) return } // 指针传参 func func4() { var err error defer func(err *error) { fmt.Println(*err) }(\u0026amp;err) err = errors.New(\u0026#34;func4 error\u0026#34;) return } func main() { func1() func2() func3() func4() } 执行结果：\n\u0026lt;nil\u0026gt; func2 error \u0026lt;nil\u0026gt; func4 error 解析：\n第一个和第三个函数中，都是作为参数，进行值传参，err 在定义的时候就会求值，因为定义的时候值都是nil ，所以最后的结果都是nil ；\n第二个函数的参数在定义的时候也求值了，但是它是个闭包，查看上下文发现最后值被修改为func2 error ；\n第四个函数是指针传参，最后值被修改为func4 error ；\n现实中，第三个函数闭包的例子是比较容易犯的错误，导致最后defer 语句没有起到作用，造成生产上的事故，需要特别注意。\n三、defer的语句拆解 从返回值出发来拆解延迟语句 defer 。\n​\treturn xxx\n这条语句经过编译之后，实际上生成了三条指令：\n返回值 = xxx 调用 defer 函数 空的 return 其中，1 和 3 是return 语句生成的指令，2 是defer 语句生成的指令。可以看出：\nreturn 并不是一条原子指令；defer 语句在第二步调用，这里可能操作返回值，从而影响最终结果。\n接下来通过例子来加深理解。\n例子1：\nfunc func1() (r int) { t := 3 defer func() { t = t + 3 }() return t } func main() { r := func1() fmt.Println(r) } 执行结果：\n3 语句拆解：\nfunc func1() (r int) { t := 3 // 1.返回值=xxx：赋值指令 r = t // 2.调用defer函数：defer在赋值与返回之前执行，这个例子中返回值r没有被修改过 func() { t = t + 3 }() // 3.空的return return } func main() { r := func1() fmt.Println(r) } 解析：因为第二个步骤里并没有操作返回值r ，所以最终得到的结果是3 。\n例子2：\nfunc func2() (r int) { defer func(r int) { r = r + 3 }(r) return 1 } func main() { r := func2() fmt.Println(r) } 执行结果：\n1 语句拆解：\nfunc func2() (r int) { // 1.返回值=xxx：赋值指令 r = 1 // 2.调用defer函数：因为是值传参，所以修改的r是个复制的值，不会影响要返回的那个r值。 func(r int) { r = r + 3 }(r) // 3.空的return return } func main() { r := func2() fmt.Println(r) } 解析：因为第二个步骤里改变的是传值进去的r 值，是一个形参的复制值，不会影响实参r ，所以最终得到的结果是1 。\n例子3：\nfunc func3() (r int) { defer func() { r = r + 3 }() return 1 } func main() { r := func3() fmt.Println(r) } 执行结果：\n4 语句拆解：\nfunc func3() (r int) { // 1.返回值=xxx：赋值指令 r = 1 // 2.调用defer函数：因为是闭包，捕获的变量是引用传递，所以会修改返回的那个r值。 func() { r = r + 3 }() // 3.空的return return } func main() { r := func3() fmt.Println(r) } 解析：因为第二个步骤里改变的r 值是闭包，闭包中捕获的变量是引用传递，不是值传递，所以最终得到的结果是4 。\n四、defer中的recover 代码中的panic 最终会被recover 捕获到。在日常开发中，可能某一条协议的逻辑触发了某一个bug 造成panic ，这时就可以用recover 去捕获panic ，稳住主流程，不影响其他协议的业务逻辑。\n需要注意的是，recover 函数只在defer 的函数中直接调用才生效。\n通过例子看recover 调用情况。\n例子1：\nfunc func1() { if err := recover(); err != nil { fmt.Println(\u0026#34;func1 recover\u0026#34;, err) return } } func main() { defer func1() panic(\u0026#34;func1 panic\u0026#34;) } 执行结果：\nfunc1 recover func1 panic 解析：正确recover ，因为在defer 中调用的，所以可以生效。\n例子2：\nfunc main() { recover() panic(\u0026#34;func2 panic\u0026#34;) } 执行结果：\npanic: func2 panic goroutine 1 [running]: main.main() C:/Users/ycz/go/ccc.go:5 +0x31 exit status 2 解析：错误recover ，直接调用recover ，返回nil 。\n例子3：\nfunc main() { defer recover() panic(\u0026#34;func3 panic\u0026#34;) } 执行结果：\npanic: func3 panic goroutine 1 [running]: main.main() C:/Users/ycz/go/ccc.go:5 +0x65 exit status 2 解析：错误recover ，recover 需要在defer 的函数里调用。\n例子4：\nfunc main() { defer func() { defer func() { recover() }() }() panic(\u0026#34;func4 panic\u0026#34;) } 执行结果：\npanic: func4 panic goroutine 1 [running]: main.main() C:/Users/ycz/go/ccc.go:9 +0x49 exit status 2 解析：错误recover ，不能在多重defer 嵌套里调用recover 。\n另外需要注意的一点是，父goroutine 无法 recover 住 子goroutine 的 panic 。\n原因是，goroutine 被设计为一个独立的代码执行单元，拥有自己的执行栈，不与其他goroutine 共享任何的数据。\n也就是说，无法让goroutine 拥有返回值，也无法让goroutine 拥有自身的ID 编号。\n如果希望有一个全局的panic 捕获中心，那么可以通过channel 来实现，如下示例：\nvar panicNotifyManage chan interface{} func StartGlobalPanicRecover() { panicNotifyManage = make(chan interface{}) go func() { select { case err := \u0026lt;-panicNotifyManage: fmt.Println(\u0026#34;panicNotifyManage---\u0026gt;\u0026#34;, err) } }() } func GoSafe(f func()) { go func() { defer func() { if err := recover(); err != nil { panicNotifyManage \u0026lt;- err } }() f() }() } func main() { StartGlobalPanicRecover() f1 := func() { panic(\u0026#34;f1 panic\u0026#34;) } GoSafe(f1) time.Sleep(time.Second) } 解析：GoSafe() 本质上是对go 关键字进行了一层封装，确保在执行并发单元前插入一个defer ，从而保证能够recover 住panic 。但是这个方案并不完美，如果开发人员不使用GoSafe 函数来创建goroutine ，而是自己创建，并且在代码中出现了panic ，那么仍然会造成程序崩溃。\n","date":"2025-05-10T23:03:15+08:00","image":"http://localhost:1313/p/defer/2_hu_6fea82e8afbdd5a7.png","permalink":"http://localhost:1313/p/defer/","title":"defer"},{"content":"源码剖析 通过日常随机数的代码使用，看下rank包具体的底层实现：\nr := rand.New(rand.NewSource(time.Now().UnixNano())) // 初始化随机器 r.Intn(314)\t// 生成 [0, 314) 内的整数 从r := rand.New(rand.NewSource(time.Now().UnixNano())) 开始。\n初始化 Rand 的时候，通过rand.New(rand.NewSource(seed))创建，所以看下rand.New()的实现。\n// New returns a new Rand that uses random values from src // to generate other random values. func New(src Source) *Rand { s64, _ := src.(Source64) return \u0026amp;Rand{src: src, s64: s64} } 可以看到 Rand 使用的是rand.NewSource()传入的 Source，因此接着看下rand.NewSource()的实现。\n// NewSource returns a new pseudo-random Source seeded with the given value. // Unlike the default Source used by top-level functions, this source is not // safe for concurrent use by multiple goroutines. // The returned Source implements Source64. func NewSource(seed int64) Source { return newSource(seed) } func newSource(seed int64) *rngSource { var rng rngSource rng.Seed(seed) return \u0026amp;rng } 看到 Source 的实际类型是 rngSource，实现了接口 Source。\ntype rngSource struct { tap int // index into vec feed int // index into vec vec [rngLen]int64 // current feedback register } 看下接口 Source的定义。\n// A Source represents a source of uniformly-distributed // pseudo-random int64 values in the range [0, 1\u0026lt;\u0026lt;63). // // A Source is not safe for concurrent use by multiple goroutines. type Source interface { Int63() int64 Seed(seed int64) } 从 newSource 中，可以看到调用了 rng.Seed(seed) ，即 rngSource 的 Seed ，这个就是随机器初始化的核心函数。\nconst ( rngLen = 607 rngTap = 273 rngMax = 1 \u0026lt;\u0026lt; 63 rngMask = rngMax - 1 int32max = (1 \u0026lt;\u0026lt; 31) - 1 ) // Seed uses the provided seed value to initialize the generator to a deterministic state. func (rng *rngSource) Seed(seed int64) { rng.tap = 0 rng.feed = rngLen - rngTap seed = seed % int32max if seed \u0026lt; 0 { seed += int32max } if seed == 0 { seed = 89482311 } x := int32(seed) for i := -20; i \u0026lt; rngLen; i++ { x = seedrand(x) if i \u0026gt;= 0 { var u int64 u = int64(x) \u0026lt;\u0026lt; 40 x = seedrand(x) u ^= int64(x) \u0026lt;\u0026lt; 20 x = seedrand(x) u ^= int64(x) u ^= rngCooked[i] rng.vec[i] = u } } } // seed rng x[n+1] = 48271 * x[n] mod (2**31 - 1) func seedrand(x int32) int32 { const ( A = 48271 Q = 44488 R = 3399 ) hi := x / Q lo := x % Q x = A*lo - R*hi if x \u0026lt; 0 { x += int32max } return x } 通过逻辑可以看出，调用 rand.Seed 来设置种子, 其实就是给 rng.vec 的 607 个槽设置对应的值。通过上面的源码那可以看出来, rand.Seed 会调用一个 seedrand 的函数, 来计算对应槽的值。这个函数的计算结果并不是随机的，而是根据 seed 实际算出来的，另外这个函数并不是随便写的，是有相关的数学证明的。 这也导致了相同的 seed，最终设置到 rng.vec 里面的值是相同的。 总结下，随机器初始化的逻辑其实就是为了进行 rng.tap、rng.feed、 rng.vec 的初始化工作。 其中，需要特别注意的是： 相同的seed种子 或者 seed种子取模int32最大值后相等； 这两种情况都会导致最终设置到 rng.vec 里面的值是相同的。\n以上就是随机器初始化，接下来看下随机数是如何产生的。 从r.Intn(314) 开始解析。 以 rand.Intn() 为例，看下具体的实现。\n// Intn returns, as an int, a non-negative pseudo-random number in the half-open interval [0,n). // It panics if n \u0026lt;= 0. func (r *Rand) Intn(n int) int { if n \u0026lt;= 0 { panic(\u0026#34;invalid argument to Intn\u0026#34;) } if n \u0026lt;= 1\u0026lt;\u0026lt;31-1 { return int(r.Int31n(int32(n))) } return int(r.Int63n(int64(n))) } 查看源码可了解到，小于等于 MaxInt32 的值调用的是 r.Int31n 。\n// Int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n). // It panics if n \u0026lt;= 0. func (r *Rand) Int31n(n int32) int32 { if n \u0026lt;= 0 { panic(\u0026#34;invalid argument to Int31n\u0026#34;) } if n\u0026amp;(n-1) == 0 { // n is power of two, can mask return r.Int31() \u0026amp; (n - 1) } max := int32((1 \u0026lt;\u0026lt; 31) - 1 - (1\u0026lt;\u0026lt;31)%uint32(n)) v := r.Int31() for v \u0026gt; max { v = r.Int31() } return v % n } 如果传入的值是2的幂次方，则调用的 r.Int31() \u0026amp; (n - 1) ；\n因为传入的314不是2的幂次方，所以走的是 max := int32((1 \u0026lt;\u0026lt; 31) - 1 - (1\u0026lt;\u0026lt;31)%uint32(n)) 下面的逻辑。\n针对 max 这个逻辑，需要理解它的用途，它其实是将 int32 0, (1 \u0026lt;\u0026lt; 31) - 1 范围内尾部，“取模后”，不能覆盖 [0, n) 的数值去掉，这样就保证了 [0, n) 内各个数值出现的概率是一致的。举例如下：\nvar n int32 = 314 tail := (1 \u0026lt;\u0026lt; 31) % uint32(n) max := int32((1 \u0026lt;\u0026lt; 31) - 1 - (1\u0026lt;\u0026lt;31)%uint32(n)) fmt.Println(tail) // 282 fmt.Println(max) // 2147483365 fmt.Println(max % n) // 313 继续往下看逻辑，无论是不是2的幂次方，最终都会调用到 r.Int31() ，所以需要看 r.Int31() 的具体实现。\n// Int31 returns a non-negative pseudo-random 31-bit integer as an int32. func (r *Rand) Int31() int32 { return int32(r.Int63() \u0026gt;\u0026gt; 32) } r.Int31() 中调用的是 r.Int63() ，然后取结果的高31位作为 int32 随机值，下面看 r.Int63() 的实现。\n// Int63 returns a non-negative pseudo-random 63-bit integer as an int64. func (r *Rand) Int63() int64 { return r.src.Int63() } 可以看到，最终调用的是 r.src.Int63() 。\n看下Rand的定义，因为上面已经分析出了Rand的src的具体实现就是 rngSource。\n// A Rand is a source of random numbers. type Rand struct { src Source s64 Source64 // non-nil if src is source64 // readVal contains remainder of 63-bit integer used for bytes // generation during most recent Read call. // It is saved so next Read call can start where the previous // one finished. readVal int64 // readPos indicates the number of low-order bytes of readVal // that are still valid. readPos int8 } 因此，随机数的产生调用的就是 rngSource 结构体的 Int63 函数。\n// Int63 returns a non-negative pseudo-random 63-bit integer as an int64. func (rng *rngSource) Int63() int64 { return int64(rng.Uint64() \u0026amp; rngMask) } 其中 rngMask 表示 Int64 的最大值，作用是作为掩码。\nrngMax = 1 \u0026lt;\u0026lt; 63 rngMask = rngMax - 1 而 rng.Uint64() ，则是产生随机数的核心函数；它的核心逻辑就是从数组 rngSource.vec 中取出随机数。\n// Uint64 returns a non-negative pseudo-random 64-bit integer as an uint64. func (rng *rngSource) Uint64() uint64 { rng.tap-- if rng.tap \u0026lt; 0 { rng.tap += rngLen } rng.feed-- if rng.feed \u0026lt; 0 { rng.feed += rngLen } x := rng.vec[rng.feed] + rng.vec[rng.tap] rng.vec[rng.feed] = x return uint64(x) } 实际上，调用 Intn(), Int31n(), Int63(), Int63n() 等其他随机函数，最终调用到都是函数 rngSource.Uint64() 。可以看到每次调用就是利用 rng.feed, rng.tap 从 rng.vec 中取到两个值相加的结果返回，同时这个结果又重新放入 rng.vec。这样做的目的是，让随机数更加丰富随机，而不是仅局限于 rng.vec 数组中的值。\n源码总结 通过以上的源码分析，可以总结出以下几点：\nrand.New 初始化出来的 rand 不是并发安全的。 因为每次利用 rng.feed, rng.tap 从 rng.vec 中取到随机值后会将随机值重新放入 rng.vec，当多 goroutine 同时调用时就会有数据竞争问题。如果想并发安全，可以使用全局的随机数发生器 rand.globalRand，它是基于lockedSource实现的，进行了加锁的逻辑。 相同seed种子，每次运行的结果是一样的。 因为随机数是从 rng.vec 数组中取出来的，这个数组是根据种子生成的，相同的种子生成的 rng.vec 数组是相同的。 不同seed种子，每次运行的结果可能一样。 因为根据种子生成 rng.vec 数组时会有一个对int32最大值取模的操作，模后的结果可能相同，也就是两个种子如果相差int32的最大值，就会导致 rng.vec 数组相同。 r1 := rand.New(rand.NewSource(1111)) r2 := rand.New(rand.NewSource(1111 + math.MaxInt32)) fmt.Println(\u0026#34;第一个随机器：\u0026#34;, r1.Intn(10000)) // 第一个随机器： 9241 fmt.Println(\u0026#34;第一个随机器：\u0026#34;, r1.Intn(10000)) // 第一个随机器： 8842 fmt.Println(\u0026#34;第一个随机器：\u0026#34;, r1.Intn(10000)) // 第一个随机器： 2221 fmt.Println(\u0026#34;第二个随机器：\u0026#34;, r2.Intn(10000)) // 第二个随机器： 9241 fmt.Println(\u0026#34;第二个随机器：\u0026#34;, r2.Intn(10000)) // 第二个随机器： 8842 fmt.Println(\u0026#34;第二个随机器：\u0026#34;, r2.Intn(10000)) // 第二个随机器： 2221 ","date":"2025-05-10T22:26:34+08:00","image":"http://localhost:1313/p/rand/2_hu_6fea82e8afbdd5a7.png","permalink":"http://localhost:1313/p/rand/","title":"rand"}]